let c;
let canvas;

let zoff = 0;

function setup(){
   
    c = createCanvas(1080, 1080);
    canvas = c.canvas;

    // frameRate(60);
           
    background(255);
    
    easycam = createEasyCam();    
}

function draw(){ 
    
    
    if(frameCount == 1){
        // capturer.start();
    }

    //Lowering alpha and removing background gives a nice design 
    background(255);
    // stroke(255);
    noFill();

    translate(width/2, width/2, 0);
    
    constructNoiseSphere(20); 

    // if(count == 360){
    //     // count = 1;
    //     capturer.stop();
    //     capturer.save();
    //     noLoop();
    // }
    // else{
    //     count++;
    // }

    zoff = zoff + 0.01;
    // capturer.capture(canvas);
}

//Create a noise circle
function constructNoiseCircle(noiseMax, zoff){

    beginShape();
    for(let i=0; i < TWO_PI; i+=0.1){

        //Two perlin noise values are created so as to make use of a 2d perlin noise space
        //xoff and yoff are being generated by the unique valeus obtained by the parametric equations and mapping these values to a range between
        //0 and noiseMax such that noiseMax is a value used to control how high the noise in the circle should be
        //Higher noiseMax values give a more dirupted circle

        let xoff = map(cos(i), -1, 1, 0, noiseMax);
        let yoff = map(sin(i), -1, 1, 0, noiseMax);

        //Obtaining nosie values for radius of the current point on the current circle
        let r = noise(xoff, yoff, zoff)*400;
    
        let x = r*cos(i);
        let y = r*sin(i);

        vertex(x, y);
        // vertex(x + 50, y);

    }

    endShape(CLOSE);
}

//Construct a number of circles which generate a "noise sphere"
//The number of segments corresponds to the number of circles in the sphere
function constructNoiseSphere(segments){

    //The length of the interval between each segment
    let interval = floor(width/segments);

    //At each interval construct a circle
    for(let i = interval; i < width; i+= interval){
        //The counter i will be used to go through each interval

        //Setting up colour here

        push();
        
        //Interesting circle effect
        // translate(0, 0, i*5);
        // translate(0, 0, i);

        //Maybe the best thing to do for maxNoise is map the maxNoise value between 0 and 1 and 0 width depending on the curr interval
        //Change the mapping between 0 and 3 for some nicer results
        let noiseMax = map(i, 0, width, 0, 0.5);

        //Obtaining a noise value for colour and setting up the stroke for the individual circles in the noisesphere
        let colour = noise(i)*255;
        stroke(colour, 200, 100,  255 - colour);

        //A global zoff variable is added to the current Interval value so as to keep a unique perlin noise value for each interval and generate unique movements
        constructNoiseCircle(noiseMax, zoff);
        pop();
    }       
}

function keyPressed() {
    if (keyCode === LEFT_ARROW) {
      zoff += 0.05;
    }

    if (keyCode === RIGHT_ARROW) {
        saveCanvas(c, 'NaturalCircle_LowAlph_NoBG', 'png');
      }
}